* 美しいAPIを設計する
** 柔軟な引数処理
*** 標準的な順序付き引数
: def distance(x1,y1,x2,y2)
:   Math.hypot(x2-x1,y2-y1)
: end

*** オプションパラメタのある順序付き引数
オプションパラメタが2つ以上あるときに、1つだけ変えたい場合はすべてのパラメタを指定しなければならない。
: def load_file(name="hoge.rb",mode="rb")
:   File.open(name,mode)
: end

*** 疑似キーワード引数
ハッシュを渡すことで、キーワード引数っぽくできる。
ハッシュのシンタックスシュガーをつかうと、より自然に。

キーワード引数をつかうと、「順序つき引数」ではできなかった、複数のデフォルト値を処理できる
: def story(opts)
:   opts = {person:"Ichiro",animal:"Tiger"}.merge(opts)
:   "#{opts[:person]} and #{opts[:animal]}"
: end
*** 引数を配列として扱う
: def distance2(*points)
:   distance(*points.flatten)
: end
*** 引数をつかうときのガイドライン
- 順序付き引数は最小限に。
- デフォルト値をもつパラメタが複数あるときは、ハッシュによる疑似キーワード引数の利用を考える
- 引数のならびを別メソッドに渡したいとき、配列splat演算子(*)をつかう
- 複数の引数処理をするとき、*args構文をつかってcase文で分岐させる方法がある。(ただし複雑だ)
- 順序付き引数と、optionsハッシュを組み合わせる場合、*argsをつかってはいいえない
- 必須のパラメタは、optionsハッシュに入れない。特別な理由がなければ foo(p1,p2,options={})とする。
** コードブロック
*** Enumerableを使う
Enumerableモジュールをインクルードする。
それだけでRubyの組込みの機能がほぼつかえるようになる。
inject,map,select,to_aなどなど。
[[file:ch2/sorted_list.rb]]
Enumerableのインクルードされたクラスに、メソッドを追加すると便利なことも。
*** 前処理と後処理を抽象化するためにブロックを使う
前処理と後処理が複数のメソッドで共通している場合、
ブロック付きのメソッドを想定すると、楽になる。
[[file:ch2/setup.rb]]
ソケットで必ずクローズにしたい場合などに便利。rspecなど、テストフレームワークで使われている。
*** 動的コールバックとしてのブロック
Rubyでは、コードブロックをオブジェクトのように渡せる。
このおかげで、コールバックを作成して格納しておき、必要なときに呼び出すことができる。
[[file:ch2/dynamic_callback.rb][server側]]と[[file:ch2/dynamic_callback_client.rb][client側]。
*** もっとシンプルにするためのブロック
[[file:ch2/dynamic_callback.rb]] をもっとDRYにする。
self.runをつけて、ブロックとして渡すと以下のように完結になる。
これは、インスタンス化されたオブジェクトのスコープ内でブロックを実行でくるという特性を利用したもの。
[[file:ch2/dynamic_callback_simpler.rb][もっとシンプルに]]

*** ブロックをインターフェイスの一部として使うときのガイドライン
- トラバースする必要のあるコレクションクラスを作るときは、Enumerableモジュールをつかう
- 中央部分だけが異なるコードがあるときは、前後処理のあいだにブロックをyieldするようなヘルパーメソッドをつくる
- &block構文をつかいたければ、コードブロックを変数に保存しておき、あとで使えるようにする
- &blockとinstance_evalを組み合わせると、任意のオブジェクトのコンテキストでブロックを実行できる。
- yieldと、block.callの戻値は、与えられたブロックの戻値と同じにする。

** 驚かせないこと
*** attr_* をつかう
オブジェクトの内部状態に外部から直接アクセスすることはできない。
だから、内部オブジェクトへのパブリックアクセサヲ提供する必要がある。
この際、attr_*をつかうと、シンプル。

*** method? method!
**** method? オブジェクトに問い合わせる
真偽値を返す
無理やりBool型にするために !! をつかうこともある。
: !!(nil) #=> false
: !!(12)  #=> true

: def person?
:   !!@person
: end
**** method! 「注意しろ」
レシーバに破壊的な変更を加えるものにつくのであれば、もっとたくさん!がつくはず。
破壊的な操作をすることを意味するわけではない。

ActiveRecordのcreate と create! では、
後者のほうが、厳格な対応(エラーを発生させる)をする。

*** カスタム演算子をつかう
[[file:ch2/append_and_spaceship.rb]]
**** append演算子(<<)
オブジェクト自身を返すと、メソッド呼び出しをチェーンにすることができる。
: def <<(msg)
:   @unread_count += 1
:   @messages << msg
:   return self
: end
: obj << "msg1" << "msg2"

**** スペースシップ演算子(<=>)
Comparableが利用できるようになり、比較メソッドが使える

*** 慣習まとめ
アクセサを書くときは、attr_*をつかおう。
条件文で使うためのメソッドには method? を。
foo()とほぼおなじだけど、注意が必要なメソッドがあればfoo!()と名付ける。
foo()がないならば、foo!()はつくらない。
必要があれば、カスタム演算子をつくろう
